#pragma once

//******************************************************************************
// Includes
//******************************************************************************

#include <string>
#include <utility>  // move

//
#include "Systems/Block/BlockVariables/Types.hpp"
//
#include "Systems/Block/BlockVariables/Protocols.hpp"
#include "Systems/Block/BlockVariables/TypeTraits.hpp"
//
// #include "Utilities/PrettyType.hpp"
#include "Utilities/ProtocolHelpers.hpp"

namespace blocks {

  //****************************************************************************
  /*!\brief Marks a variable in the blocks infrastructure
  // \ingroup blocks
  //
  // \details
  // Variable declares a user-defined variable in the blocks hierarchy in a
  // declarative as opposed to an imperative C++ fashion. This means that the
  // actual type and value of the variable are implementation details and can
  // be customized/changed---rather the user, at a higher level, hints at what
  // type-class the data needs to be (such as a Scalar, Vector, Matrix, Tensor)
  // and what the name of the Variable is.
  //
  // \usage
  // For any type `Var`,
     \code
     using result = blocks::Variable<ParameterTag, RankTag,
                                     OtherTagOne, OtherTagTwo>;
     \endcode
  //
  // As seen above, an instantiation of Variable requires at least two types.
  // The first one is the `ParameterTag` which is a unique type to be associated
  // with the Variable. Its used to retrieve/store the final-data in the star
  // hierarchy afforded by the Block. This type needs to only be declared, but
  // not necessarily defined.
  //
  // The second type `RankTag` is for customizing the actual data-structure that
  // the block will finally contain. This data-type is defined as the nested
  // `type` inside `RankTag`. Additionally, `RankTag` is also expected to
  // provide the type definition `slice_type` which indicates the type of a
  // slice/view into the `type`.
  //
  // Additionally, to customize the Variable or to add functionalities, one can
  // have other `Tags...` in the Variable template. These `Tags...` usually
  // provide static (with/without constexpr) member functions to modify the
  // Variable behavior. In the usage above, these correspong to `OtherTagOne` &
  // `OtherTagTwo`, although there can be more.
  //
  // \example
  // With the setup for Tags shown below
  // \snippet BlockVariables/Test_BlockVariables.cpp block_variable_setup
  //
  // the following code demonstrates the use of Variable
  // \snippet BlockVariables/Test_BlockVariables.cpp block_variable_eg
  //
  // While the example above indicates how to instantiate a Variable, the
  // actual instantiation inside a class hierarchy can be customized further by
  // inheritance to provide more context to the user. For example,
  // \snippet BlockVariables/Test_BlockVariables.cpp block_variable_derived_eg
  //
  // \note
  // Here we just declare the Variable and its data type, but the actual
  // initialization is deferred until its concrete-use inside a class-hierarchy.
  // The Variable (i.e. its data) is then default initialized at this point. To
  // force explicit (as opposed to default) initialization, see
  // InitializedVariable.
  //
  // \tparam ParameterTag A unique type parameter to mark the Variable with
  // \tparam RankTag      A type(class) for customizing the data implementation
  // \tparam Tags...      Other types to provide customization by inheritance
  //
  // \see Block, blocks::get()
  */
  template <typename ParameterTag, typename RankTag, typename... Tags>
  struct Variable
      : public tt::ConformsTo<protocols::Variable>,
        /*public ParameterTag,*/  // Don't inherit to support tags that are only
                                  // declared, but not defined
        public RankTag,
        public Tags... {
    //**Type definitions********************************************************
    //! This type
    using This = Variable<ParameterTag, RankTag, Tags...>;
    //! UUID Parameter type
    using Parameter = ParameterTag;
    //! Rank type
    using Rank = RankTag;
    //! Data type to be stored
    using type = typename Rank::type;
    // needed because VariableSlice requires a second template parameter
    // that will not be well-This to be well-formed
    // using SliceType = typename Rank::template Slice<This>;
    //! Type of slice generated by this Variable
    using SliceType = VariableSlice<This>;
    //! Type of const slice generated by this Variable
    using ConstSliceType = ConstVariableSlice<This>;
    //**************************************************************************

    //**************************************************************************
    //! Name of variable
    // static std::string name() { return pretty_type::name<ParameterTag>(); }
    static std::string name() { return ParameterTag::name(); }
    //**************************************************************************
  };
  //****************************************************************************

  //****************************************************************************
  /*!\brief An initialized Variable in the blocks infrastructure
  // \ingroup blocks
  //
  // \details
  // An InitializedVariable not only declares a Variable, but also sets up the
  // necessary infrastructure to initialize it from user input. That is, while a
  // Variable default initializes its data, an InitializedVariable forgoes this
  // and marks the data for explicit instantiation. The infrastructure for such
  // initializations is provided by BlockInitializer and initialize().
  //
  // The usage is similar to Variable, see the example below for clarification.
  //
  // \example
  // With the setup for Tags shown below
  // \snippet BlockVariables/Test_BlockVariables.cpp block_variable_setup
  //
  // the following code demonstrates the use of InitializedVariable
  // \snippet BlockVariables/Test_BlockVariables.cpp init_block_variable_eg
  //
  // Similar to Variable, InitializedVariable can also be used by deriving as
  // opposed to aliasing for more context.
  //
  // \tparam ParameterTag A unique type parameter to mark the Variable with
  // \tparam RankTag      A type(class) for customizing the data implementation
  // \tparam Tags...      Other types to provide customization by inheritance
  //
  // \see Block, blocks::initialize(), Variable
  */
  template <typename ParameterTag, typename RankTag, typename... Tags>
  struct InitializedVariable : public Variable<ParameterTag, RankTag, Tags...> {
    //**Type definitions********************************************************
    using Initializer = ParameterTag;
    //**************************************************************************
  };
  //****************************************************************************

  namespace detail {

    //**************************************************************************
    /*! \cond ELASTICA_INTERNAL */
    /*!\brief Data Slice type within the blocks infrastructure
    // \ingroup blocks
    //
    // \note
    // We separate this from the actual variable slice to prevent unnecessary
    // template instantiations
    */
    template <typename R>
    struct SliceImpl {
      //**Type definitions******************************************************
      //! Rank type
      using Rank = R;
      //! Data type to be stored
      using type = typename Rank::slice_type;
      //************************************************************************
      /*
      constexpr type& get() & noexcept { return d_; }
      constexpr type const& get() const& noexcept { return d_; }
      constexpr type&& get() && noexcept { return std::move(d_); }
      type d_;
      */
    };
    /*! \endcond */
    //**************************************************************************

    //**************************************************************************
    /*! \cond ELASTICA_INTERNAL */
    /*!\brief Const Data Slice type within the blocks infrastructure
    // \ingroup blocks
    //
    // \note
    // We separate this from the actual variable slice to prevent unnecessary
    // template instantiations
    */
    template <typename R>
    struct ConstSliceImpl {
      //**Type definitions******************************************************
      //! Rank type
      using Rank = R;
      //! Data type to be stored
      using type = typename Rank::const_slice_type;
      //************************************************************************
      /*
      constexpr type& get() & noexcept { return d_; }
      constexpr type const& get() const& noexcept { return d_; }
      constexpr type&& get() && noexcept { return std::move(d_); }
      type d_;
      */
    };
    /*! \endcond */
    //**************************************************************************

    //**************************************************************************
    /*! \cond ELASTICA_INTERNAL */
    /*!\brief Slice of a variable within the blocks infrastructure
    // \ingroup blocks
    */
    template <typename Variable_, template <typename> class SliceImplementation>
    struct VariableSlice : /*public tt::ConformsTo<protocols::Variable>,*/
                           SliceImplementation<typename Variable_::Rank> {
      //**Type definitions******************************************************
      //!
      using Variable = Variable_;
      //! Parent type
      using Parent = SliceImplementation<typename Variable::Rank>;
      //! UUID Parameter type
      using Parameter = typename Variable::Parameter;
      // using Parent::get;
      //! Rank type
      using typename Parent::Rank;
      //! Data type to be stored
      using typename Parent::type;
      //************************************************************************

      // the following code for compile-time check might not necessarily be
      // true. for example, when we derive a struct from Variable,
      // VariableSlice::This = VariableSlice<Derived>
      // while Derived::SliceType = VariableSlice<Variable>
      // which is not matched
      //    static_assert(std::is_same<typename Variable::SliceType,
      //    This>::value,
      //                  "Invariant violation in slices");
    };
    /*! \endcond */
    //**************************************************************************

  }  // namespace detail

  //****************************************************************************
  /*!\brief Marks the slice of a variable in the blocks infrastructure
  // \ingroup blocks
  //
  // \details
  // VariableSlice refers to a slice/view of a user-defined variable within
  // the blocks hierarchy. It takes in a valid Variable as a template and marks
  // its held data as a slice of the Variable data.
  //
  // \usage
  // For any valid (aka conforming to protocols) variable type `Var`, we declare
  // a VariableSlice like so
     \code
     using result = blocks::VariableSlice<Var>;
     \endcode
  //
  // The VariableSlice depends predominantly on the `RankTag` passed to the
  // parent Variable, with `RankTag` expected to provide the type definition
  // `slice_type` which indicates the type of a slice/view into the `type`.
  //
  // \example
  // For the setup provided in examples of Variable and InitializedVariable,
  // repeated below for convenience, the following code uses its slice type
  // \snippet BlockVariables/Test_BlockVariables.cpp variable_slice_eg
  //
  // Similar to Variable, the actual instantiation of a VariableSlice inside a
  // class hierarchy can be customized further by inheritance to provide more
  // context to the user. For one such example, please refer to
  // CosseratRodVariableSlice.
  //
  // \todo
  // The variableslice is templated on its parent variable to avoid cross-flow
  // of information between variables of different kinds like so
  // VariableSlice<type_a> a;
  // VariableSlice<type_b> b;
  // a = b; /// should not be allowed
  //
  // but its use in a tagged tuple disallows this sort of value syntax. How to
  // resolve this type safety issue?
  //
  // \tparam Variable A valid block variable
  //
  // \see Variable, InitializedVariable, ConstVariableSlice
  */
  template <typename Variable>
  struct VariableSlice
      : public detail::VariableSlice<Variable, detail::SliceImpl> {
    //**Type definitions********************************************************
    //! This type
    using This = VariableSlice<Variable>;
    //**************************************************************************

    //**************************************************************************
    //! Name of variable
    static std::string name() { return Variable::name(); }
    //**************************************************************************
  };
  //****************************************************************************

  //****************************************************************************
  /*!\brief Marks a constant slice of a variable in the blocks infrastructure
  // \ingroup blocks
  //
  // \details
  // ConstVariableSlice refers to a const slice/view of a user-defined variable
  // within the blocks hierarchy. It takes in a valid Variable as a template and
  // marks its held data as a const slice of the Variable data.
  //
  // \usage
  // For any valid (aka conforming to protocols) variable type `Var`, we declare
  // a ConstVariableSlice like so
     \code
     using result = blocks::ConstVariableSlice<Var>;
     \endcode
  //
  // The ConstVariableSlice depends predominantly on the `RankTag` passed to the
  // parent Variable, with `RankTag` expected to provide the type definition
  // `slice_type` which indicates the type of a slice/view into the `type`.
  //
  // \example
  // For the setup provided in examples of Variable and InitializedVariable,
  // repeated below for convenience, the following code uses its constant slice
  // type
  // \snippet BlockVariables/Test_BlockVariables.cpp const_variable_slice_eg
  //
  // Similar to Variable, the actual instantiation of a ConstVariableSlice
  // inside a class hierarchy can be customized further by inheritance to
  // provide more context to the user. For one such example, please refer to
  // CosseratRodConstVariableSlice.
  //
  // \todo
  // The variableslice is templated on its parent variable to avoid cross-flow
  // of information between variables of different kinds like so
  // ConstVariableSlice<type_a> a;
  // ConstVariableSlice<type_b> b;
  // a = b; /// should not be allowed
  //
  // but its use in a tagged tuple disallows this sort of value syntax. How to
  // resolve this type safety issue?
  //
  // \tparam Variable A valid block variable
  //
  // \see Variable, InitializedVariable, VariableSlice
  */
  template <typename Variable>
  struct ConstVariableSlice
      : public detail::VariableSlice<Variable, detail::ConstSliceImpl> {
    //**Type definitions********************************************************
    //! This type
    using This = ConstVariableSlice<Variable>;
    //**************************************************************************

    //**************************************************************************
    //! Name of variable
    static std::string name() { return Variable::name(); }
    //**************************************************************************
  };
  //****************************************************************************

  //****************************************************************************
  /*! \cond ELASTICA_INTERNAL */
  /*!\brief Specialization of same_as for Variable
  // \ingroup blocks
  */
  template <typename SourceTag, typename RankTag, typename... Tags>
  struct same_as<Variable<SourceTag, RankTag, Tags...>> {
    //**************************************************************************
    template <typename ParameterTag>
    struct with : public Variable<ParameterTag, RankTag, Tags...> {};
    //**************************************************************************
  };
  /*! \endcond */
  //****************************************************************************

  //****************************************************************************
  /*! \cond ELASTICA_INTERNAL */
  /*!\brief Specialization of same_as for InitializedVariable
  // \ingroup blocks
  */
  template <typename SourceTag, typename RankTag, typename... Tags>
  struct same_as<InitializedVariable<SourceTag, RankTag, Tags...>> {
    //**************************************************************************
    template <typename ParameterTag>
    struct with : public InitializedVariable<ParameterTag, RankTag, Tags...> {};
    //**************************************************************************
  };
  /*! \endcond */
  //****************************************************************************

  //****************************************************************************
  /*!\brief Marks a new Variable with the same attributes as another Variable
  // \ingroup blocks
  //
  // \details
  // same_as eases the creation of new Variable in blocks hierarchy by reusing
  // attributes from another Variable. It takes in a valid Variable as a
  // template and creates a new Variable using the nested with struct.
  //
  // \usage
  // For any valid (aka conforming to protocols) variable type
  // `VariableOrDerivedVariable`, we declare a new Variable, with some tag `T`,
  // like so
     \code
     using result = blocks::same_as<Var>::with<T>;
     \endcode
  //
  // In the code above `result` has the same attributes as the source Variable
  // `VariableOrDerivedVariable` and can be used seamlessly as a variable in the
  // blocks hierarchy.
  //
  // \example
  // For the example provided for Variable and InitializedVariable,
  // repeated below for convenience,
  // \snippet BlockVariables/Test_BlockVariables.cpp block_variable_eg
  // the following code marks a new variable type
  // \snippet BlockVariables/Test_BlockVariables.cpp block_variable_same_as_eg
  //
  // Similar to Variable, the actual instantiation of a same_as variable
  // inside a class hierarchy can be customized further by inheritance to
  // provide more context to the user. For example, the following also works and
  // can be customized by the user
  // \snippet BlockVariables/Test_BlockVariables.cpp bv_same_as_derived_eg
  //
  // We remark that VariableOrDerivedVariable need not be a block Variable, but
  // can also be derived from it. For the example provided for a derived
  // Variable repeated below for convenience,
  // \snippet BlockVariables/Test_BlockVariables.cpp block_variable_derived_eg
  // the following code also marks a new variable type
  // \snippet BlockVariables/Test_BlockVariables.cpp bv_same_as_from_derived_eg
  //
  // \tparam VariableOrDerivedVariable Either a valid block variable or any type
  //                                   deriving fom a valid block variable
  //
  // \see Variable, InitializedVariable
   */
  template <typename VariableOrDerivedVariable>
  struct same_as {
    static_assert(::tt::assert_conforms_to<VariableOrDerivedVariable,
                                           protocols::Variable>,
                  R"error(
Variable passed into same_as fails to conform to the Variable protocol. Are you
sure that it is a valid Variable/InitializedVariable in the blocks
infrastructure?
)error");

    //**************************************************************************
    /*! \cond ELASTICA_INTERNAL */
    /*!\brief Specialization of same_as for InitializedVariable
    // \ingroup blocks
    */
    template <typename ParameterTag>
    struct with
        : same_as<typename VariableOrDerivedVariable::This>::template with<
              ParameterTag> {};
    /*! \endcond */
    //**************************************************************************
  };
  //****************************************************************************

}  // namespace blocks
